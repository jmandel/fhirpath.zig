{
  "_spec_summary": [
    "AGGREGATE FUNCTIONS - General-purpose aggregation and built-in aggregate operations.",
    "All aggregate functions are STU (Standard for Trial Use).",
    "",
    "=== aggregate(aggregator : expression [, init : value]) : value ===",
    "Performs general-purpose aggregation by iterating over the input collection.",
    "Within the aggregator expression, these variables are available:",
    "  - $this: the current element being processed",
    "  - $index: the 0-based index of current element (0 for first element)",
    "  - $total: the running aggregation value",
    "$total is initialized to 'init' if provided, otherwise empty ({}).",
    "After each iteration, $total is set to the result of evaluating the aggregator.",
    "The final result is the value of $total after all elements are processed.",
    "",
    "Empty input collection: returns the init value (or empty if no init).",
    "",
    "Type behavior: aggregate does NOT enforce type homogeneity.",
    "The aggregator expression can return different types on each iteration.",
    "If the aggregator returns empty on an iteration, $total becomes empty.",
    "",
    "Common patterns:",
    "  sum:     value.aggregate($this + $total, 0)",
    "  min:     value.aggregate(iif($total.empty(), $this, iif($this < $total, $this, $total)))",
    "  max:     value.aggregate(iif($total.empty(), $this, iif($this > $total, $this, $total)))",
    "  average: value.aggregate($total + $this, 0) / value.count()",
    "",
    "=== sum() : Integer | Long | Decimal | Quantity ===",
    "Returns the sum of all elements in the input collection (in the same type).",
    "Input types: Integer, Long, Decimal, or Quantity.",
    "ALL elements must be the SAME type, otherwise an EXCEPTION is thrown.",
    "Empty input \u2192 empty result.",
    "Result type matches input type exactly.",
    "Spec examples:",
    "  (1.0 | 2.0 | 3.0 | 4.0 | 5.0).sum() \u2192 15.0",
    "  (1.0 'mg' | 2.0 'mg' | 3.0 'mg' | 4.0 'mg' | 5.0 'mg').sum() \u2192 15.0 'mg'",
    "",
    "=== min() : Integer | Long | Decimal | Quantity | Date | DateTime | Time | String ===",
    "Returns the minimum element in the input collection.",
    "Uses comparison semantics defined by Comparison Operators for the type.",
    "ALL elements must be the SAME type, otherwise an EXCEPTION is thrown.",
    "Empty input \u2192 empty result.",
    "Spec examples:",
    "  (2, 4, 8, 6).min() \u2192 2",
    "  (2L, 4L, 8L, 6L).min() \u2192 2L",
    "  (@2012-12-31, @2013-01-01, @2012-01-01).min() \u2192 @2012-01-01",
    "",
    "=== max() : Integer | Long | Decimal | Quantity | Date | DateTime | Time | String ===",
    "Returns the maximum element in the input collection.",
    "Uses comparison semantics defined by Comparison Operators for the type.",
    "ALL elements must be the SAME type, otherwise an EXCEPTION is thrown.",
    "Empty input \u2192 empty result.",
    "Spec examples:",
    "  (2, 4, 8, 6).max() \u2192 8",
    "  (2L, 4L, 8L, 6L).max() \u2192 8L",
    "  (@2012-12-31, @2013-01-01, @2012-01-01).max() \u2192 @2013-01-01",
    "",
    "=== avg() : Decimal | Quantity ===",
    "Returns the average of all elements in the input collection.",
    "Input types: Decimal or Quantity.",
    "Integer/Long inputs are IMPLICITLY CONVERTED to Decimal before evaluation.",
    "ALL elements must be the SAME type, otherwise an EXCEPTION is thrown.",
    "Empty input \u2192 empty result.",
    "Result is always Decimal (or Quantity with Decimal value).",
    "Spec examples:",
    "  (5.5 | 4.7 | 4.8).avg() \u2192 5.0",
    "  (5.5 'cm' | 4.7 'cm' | 4.8 'cm').avg() \u2192 5.0 'cm'",
    "",
    "=== Type homogeneity requirement (CRITICAL) ===",
    "For sum/min/max/avg: ALL elements MUST be the SAME type.",
    "Mixing Integer with Decimal is NOT allowed (throws exception).",
    "Mixing different Quantity units is NOT allowed (no UCUM conversion).",
    "This is stricter than aggregate(), which has no such restriction.",
    "",
    "=== Date/Time comparison notes ===",
    "For min/max with Date/DateTime/Time:",
    "- All values must have the SAME precision level.",
    "- Different precisions (e.g., @2018-03 vs @2018-03-01) would return empty.",
    "- Our tests use same-precision values to ensure deterministic results.",
    "",
    "=== String comparison ===",
    "String ordering is strictly lexical based on Unicode value of characters.",
    "'abc' < 'ABC' is false (lowercase letters have higher Unicode values).",
    "",
    "=== Quantity comparison ===",
    "For min/max with Quantity: dimensions must be the same (e.g., both mass).",
    "Units can differ IF implementation supports UCUM conversion.",
    "Without UCUM support, units must match exactly or result is empty."
  ],
  "_todo": [
    "[ ] Improve passing rate (29/74 passing)",
    "[ ] Parser: Support union operator | in parenthesized expressions (blocks 61 tests)",
    "[ ] Parser: Support $this, $index, $total special variables",
    "[ ] Parser: Support date/time literals (@2012-01-01, @T10:30:00)",
    "[ ] Parser: Support Quantity literals (1.0 'mg')",
    "[x] Implement aggregate() function with iteration variables",
    "[x] Implement sum() function",
    "[ ] Implement min() function",
    "[ ] Implement max() function",
    "[ ] Implement avg() function",
    "[ ] Add tests for Long type once supported",
    "[ ] Add error tests for mixed types (currently omitted as behavior is exception)"
  ],
  "_open_questions_resolved": [
    "Q: Does aggregate preserve type or can it change types during iteration?",
    "A: aggregate() has NO type restriction. The aggregator expression can return",
    "   different types on each iteration. $total simply holds whatever the last",
    "   evaluation returned. This is unlike sum/min/max/avg which require homogeneous types.",
    "",
    "Q: For avg with Quantity, is result unit preserved exactly?",
    "A: Yes. Per spec example: (5.5 'cm' | 4.7 'cm' | 4.8 'cm').avg() \u2192 5.0 'cm'",
    "   The unit string is preserved in the result Quantity.",
    "",
    "Q: What happens if aggregate expression returns empty on some iterations?",
    "A: $total becomes empty. Subsequent iterations will have $total.empty() = true.",
    "   This is why the min/max patterns use iif($total.empty(), ...) guards."
  ],
  "meta": {
    "status": "reviewed"
  },
  "cases": [
    {
      "_comment": "=== aggregate() basic tests ==="
    },
    {
      "name": "aggregate: sum pattern with init=0",
      "expr": "(1 | 2 | 3 | 4 | 5).aggregate($this + $total, 0)",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 15
        }
      ]
    },
    {
      "name": "aggregate: sum with non-zero init",
      "expr": "(1 | 2 | 3).aggregate($this + $total, 10)",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 16
        }
      ]
    },
    {
      "name": "aggregate: sum 1-9 equals 45 (official test)",
      "expr": "(1|2|3|4|5|6|7|8|9).aggregate($this + $total, 0) = 45",
      "input": {},
      "expect": [
        {
          "type": "boolean",
          "value": true
        }
      ]
    },
    {
      "name": "aggregate: sum 1-9 with init=2 equals 47 (official test)",
      "expr": "(1|2|3|4|5|6|7|8|9).aggregate($this + $total, 2) = 47",
      "input": {},
      "expect": [
        {
          "type": "boolean",
          "value": true
        }
      ]
    },
    {
      "name": "aggregate: min pattern (official test)",
      "expr": "(1|2|3|4|5|6|7|8|9).aggregate(iif($total.empty(), $this, iif($this < $total, $this, $total))) = 1",
      "input": {},
      "expect": [
        {
          "type": "boolean",
          "value": true
        }
      ]
    },
    {
      "name": "aggregate: max pattern (official test)",
      "expr": "(1|2|3|4|5|6|7|8|9).aggregate(iif($total.empty(), $this, iif($this > $total, $this, $total))) = 9",
      "input": {},
      "expect": [
        {
          "type": "boolean",
          "value": true
        }
      ]
    },
    {
      "name": "aggregate: empty input with init returns init",
      "expr": "{}.aggregate($this + $total, 42)",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 42
        }
      ]
    },
    {
      "name": "aggregate: empty input without init returns empty",
      "expr": "{}.aggregate($this + $total)",
      "input": {},
      "expect": []
    },
    {
      "name": "aggregate: single element with init",
      "expr": "(5).aggregate($this + $total, 0)",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 5
        }
      ]
    },
    {
      "name": "aggregate: single element without init",
      "expr": "(5).aggregate(iif($total.empty(), $this, $this + $total))",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 5
        }
      ]
    },
    {
      "name": "aggregate: product pattern",
      "expr": "(1 | 2 | 3 | 4).aggregate($this * $total, 1)",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 24
        }
      ]
    },
    {
      "name": "aggregate: string concatenation",
      "expr": "('a' | 'b' | 'c').aggregate($total & $this, '')",
      "input": {},
      "expect": [
        {
          "type": "string",
          "value": "abc"
        }
      ]
    },
    {
      "name": "aggregate: counting pattern",
      "expr": "('x' | 'y' | 'z').aggregate($total + 1, 0)",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 3
        }
      ]
    },
    {
      "name": "aggregate: with decimals",
      "expr": "(1.5 | 2.5 | 3.0).aggregate($this + $total, 0.0)",
      "input": {},
      "expect": [
        {
          "type": "decimal",
          "value": 7.0
        }
      ]
    },
    {
      "name": "aggregate: using $index for positional sum",
      "expr": "('a' | 'b' | 'c').aggregate($total + $index, 0)",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 3
        }
      ]
    },
    {
      "name": "aggregate: $index starts at 0",
      "expr": "('x').aggregate($index, 99)",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 0
        }
      ]
    },
    {
      "name": "aggregate: weighted sum using $index",
      "expr": "(10 | 20 | 30).aggregate($this * $index + $total, 0)",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 80
        }
      ]
    },
    {
      "_comment": "=== sum() tests ==="
    },
    {
      "name": "sum: integers",
      "expr": "(1 | 2 | 3 | 4 | 5).sum()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 15
        }
      ]
    },
    {
      "name": "sum: decimals",
      "expr": "(1.0 | 2.0 | 3.0 | 4.0 | 5.0).sum()",
      "input": {},
      "expect": [
        {
          "type": "decimal",
          "value": 15.0
        }
      ]
    },
    {
      "name": "sum: single integer",
      "expr": "(42).sum()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 42
        }
      ]
    },
    {
      "name": "sum: single decimal",
      "expr": "(3.14).sum()",
      "input": {},
      "expect": [
        {
          "type": "decimal",
          "value": 3.14
        }
      ]
    },
    {
      "name": "sum: empty returns empty",
      "expr": "{}.sum()",
      "input": {},
      "expect": []
    },
    {
      "name": "sum: negative integers",
      "expr": "(-1 | -2 | -3).sum()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": -6
        }
      ]
    },
    {
      "name": "sum: mixed positive and negative",
      "expr": "(-5 | 10 | -3 | 8).sum()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 10
        }
      ]
    },
    {
      "name": "sum: quantities with same unit",
      "expr": "(1.0 'mg' | 2.0 'mg' | 3.0 'mg').sum()",
      "input": {},
      "expect": [
        {
          "type": "Quantity",
          "value": {
            "value": 6.0,
            "unit": "mg"
          }
        }
      ]
    },
    {
      "name": "sum: decimal precision preserved",
      "expr": "(0.1 | 0.2).sum()",
      "input": {},
      "expect": [
        {
          "type": "decimal",
          "value": 0.3
        }
      ]
    },
    {
      "name": "sum: from field values",
      "expr": "items.value.sum()",
      "input": {
        "items": [
          {
            "value": 10
          },
          {
            "value": 20
          },
          {
            "value": 30
          }
        ]
      },
      "expect": [
        {
          "type": "integer",
          "value": 60
        }
      ]
    },
    {
      "_comment": "=== min() tests ==="
    },
    {
      "name": "min: integers",
      "expr": "(2 | 4 | 8 | 6).min()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 2
        }
      ]
    },
    {
      "name": "min: decimals",
      "expr": "(2.5 | 1.5 | 3.5).min()",
      "input": {},
      "expect": [
        {
          "type": "decimal",
          "value": 1.5
        }
      ]
    },
    {
      "name": "min: single element",
      "expr": "(42).min()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 42
        }
      ]
    },
    {
      "name": "min: empty returns empty",
      "expr": "{}.min()",
      "input": {},
      "expect": []
    },
    {
      "name": "min: strings (lexicographic)",
      "expr": "('banana' | 'apple' | 'cherry').min()",
      "input": {},
      "expect": [
        {
          "type": "string",
          "value": "apple"
        }
      ]
    },
    {
      "name": "min: dates",
      "expr": "(@2012-12-31 | @2013-01-01 | @2012-01-01).min()",
      "input": {},
      "expect": [
        {
          "type": "string",
          "value": "2012-01-01"
        }
      ]
    },
    {
      "name": "min: dateTimes",
      "expr": "(@2020-06-15T10:00:00 | @2020-06-15T08:00:00 | @2020-06-15T12:00:00).min()",
      "input": {},
      "expect": [
        {
          "type": "string",
          "value": "2020-06-15T08:00:00"
        }
      ]
    },
    {
      "name": "min: times",
      "expr": "(@T14:30:00 | @T09:00:00 | @T18:45:00).min()",
      "input": {},
      "expect": [
        {
          "type": "string",
          "value": "09:00:00"
        }
      ]
    },
    {
      "name": "min: negative integers",
      "expr": "(-5 | -2 | -8 | -1).min()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": -8
        }
      ]
    },
    {
      "name": "min: quantities",
      "expr": "(3.0 'kg' | 1.5 'kg' | 2.0 'kg').min()",
      "input": {},
      "expect": [
        {
          "type": "unknown",
          "value": {
            "value": 1.5,
            "unit": "kg"
          }
        }
      ]
    },
    {
      "name": "min: from field values",
      "expr": "items.value.min()",
      "input": {
        "items": [
          {
            "value": 30
          },
          {
            "value": 10
          },
          {
            "value": 20
          }
        ]
      },
      "expect": [
        {
          "type": "integer",
          "value": 10
        }
      ]
    },
    {
      "_comment": "=== max() tests ==="
    },
    {
      "name": "max: integers",
      "expr": "(2 | 4 | 8 | 6).max()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 8
        }
      ]
    },
    {
      "name": "max: decimals",
      "expr": "(2.5 | 1.5 | 3.5).max()",
      "input": {},
      "expect": [
        {
          "type": "decimal",
          "value": 3.5
        }
      ]
    },
    {
      "name": "max: single element",
      "expr": "(42).max()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 42
        }
      ]
    },
    {
      "name": "max: empty returns empty",
      "expr": "{}.max()",
      "input": {},
      "expect": []
    },
    {
      "name": "max: strings (lexicographic)",
      "expr": "('banana' | 'apple' | 'cherry').max()",
      "input": {},
      "expect": [
        {
          "type": "string",
          "value": "cherry"
        }
      ]
    },
    {
      "name": "max: dates",
      "expr": "(@2012-12-31 | @2013-01-01 | @2012-01-01).max()",
      "input": {},
      "expect": [
        {
          "type": "string",
          "value": "2013-01-01"
        }
      ]
    },
    {
      "name": "max: dateTimes",
      "expr": "(@2020-06-15T10:00:00 | @2020-06-15T08:00:00 | @2020-06-15T12:00:00).max()",
      "input": {},
      "expect": [
        {
          "type": "string",
          "value": "2020-06-15T12:00:00"
        }
      ]
    },
    {
      "name": "max: times",
      "expr": "(@T14:30:00 | @T09:00:00 | @T18:45:00).max()",
      "input": {},
      "expect": [
        {
          "type": "string",
          "value": "18:45:00"
        }
      ]
    },
    {
      "name": "max: negative integers",
      "expr": "(-5 | -2 | -8 | -1).max()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": -1
        }
      ]
    },
    {
      "name": "max: quantities",
      "expr": "(3.0 'kg' | 1.5 'kg' | 2.0 'kg').max()",
      "input": {},
      "expect": [
        {
          "type": "unknown",
          "value": {
            "value": 3.0,
            "unit": "kg"
          }
        }
      ]
    },
    {
      "name": "max: from field values",
      "expr": "items.value.max()",
      "input": {
        "items": [
          {
            "value": 30
          },
          {
            "value": 10
          },
          {
            "value": 20
          }
        ]
      },
      "expect": [
        {
          "type": "integer",
          "value": 30
        }
      ]
    },
    {
      "_comment": "=== avg() tests ==="
    },
    {
      "name": "avg: decimals",
      "expr": "(5.5 | 4.7 | 4.8).avg()",
      "input": {},
      "expect": [
        {
          "type": "decimal",
          "value": 5.0
        }
      ]
    },
    {
      "name": "avg: integers (converted to decimal)",
      "expr": "(2 | 4 | 6).avg()",
      "input": {},
      "expect": [
        {
          "type": "decimal",
          "value": 4.0
        }
      ]
    },
    {
      "name": "avg: single element",
      "expr": "(10.0).avg()",
      "input": {},
      "expect": [
        {
          "type": "decimal",
          "value": 10.0
        }
      ]
    },
    {
      "name": "avg: empty returns empty",
      "expr": "{}.avg()",
      "input": {},
      "expect": []
    },
    {
      "name": "avg: quantities",
      "expr": "(5.5 'cm' | 4.7 'cm' | 4.8 'cm').avg()",
      "input": {},
      "expect": [
        {
          "type": "unknown",
          "value": {
            "value": 5.0,
            "unit": "cm"
          }
        }
      ]
    },
    {
      "name": "avg: result can have decimal places",
      "expr": "(1 | 2).avg()",
      "input": {},
      "expect": [
        {
          "type": "decimal",
          "value": 1.5
        }
      ]
    },
    {
      "name": "avg: three values averaging to non-terminating decimal",
      "expr": "(1 | 1 | 1).avg()",
      "input": {},
      "expect": [
        {
          "type": "decimal",
          "value": 1.0
        }
      ]
    },
    {
      "name": "avg: from field values (integers)",
      "expr": "items.value.avg()",
      "input": {
        "items": [
          {
            "value": 10
          },
          {
            "value": 20
          },
          {
            "value": 30
          }
        ]
      },
      "expect": [
        {
          "type": "decimal",
          "value": 20.0
        }
      ]
    },
    {
      "_comment": "=== Edge cases and error conditions ==="
    },
    {
      "name": "sum: two elements",
      "expr": "(100 | 200).sum()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 300
        }
      ]
    },
    {
      "name": "min: two equal elements",
      "expr": "(5 | 5).min()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 5
        }
      ]
    },
    {
      "name": "max: two equal elements",
      "expr": "(5 | 5).max()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 5
        }
      ]
    },
    {
      "name": "min: all same values",
      "expr": "(3 | 3 | 3 | 3).min()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 3
        }
      ]
    },
    {
      "name": "max: all same values",
      "expr": "(3 | 3 | 3 | 3).max()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 3
        }
      ]
    },
    {
      "name": "sum: zero in collection",
      "expr": "(0 | 5 | 0 | 10).sum()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 15
        }
      ]
    },
    {
      "name": "avg: identical values",
      "expr": "(7.0 | 7.0 | 7.0).avg()",
      "input": {},
      "expect": [
        {
          "type": "decimal",
          "value": 7.0
        }
      ]
    },
    {
      "name": "min: first element is minimum",
      "expr": "(1 | 5 | 3 | 9).min()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 1
        }
      ]
    },
    {
      "name": "min: last element is minimum",
      "expr": "(5 | 3 | 9 | 1).min()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 1
        }
      ]
    },
    {
      "name": "max: first element is maximum",
      "expr": "(9 | 5 | 3 | 1).max()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 9
        }
      ]
    },
    {
      "name": "max: last element is maximum",
      "expr": "(1 | 3 | 5 | 9).max()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 9
        }
      ]
    }
  ]
}
