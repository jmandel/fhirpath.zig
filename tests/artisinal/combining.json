{
  "_spec_summary": [
    "Collection combining functions: union, combine, intersect, exclude",
    "",
    "=== UNION ===",
    "union(other: collection) : collection",
    "  - Merges two collections, eliminating duplicates using equals (=) not equivalence (~)",
    "  - NO expectation of order in result - implementations may return any order",
    "  - Returns distinct list of elements from both inputs",
    "  - Can also be invoked using the | operator: x.union(y) is synonymous with x | y",
    "  - A.union(B) where A:1,1,2,3 and B:2,3 \u2192 1,2,3 (any order)",
    "  - A.union({}) \u2192 distinct elements of A",
    "  - union does NOT introduce iteration context (unlike select/where)",
    "",
    "=== COMBINE ===",
    "combine(other: collection, [preserveOrder: Boolean]) : collection",
    "  - Merges WITHOUT eliminating duplicates",
    "  - When preserveOrder is false/absent: NO order guarantee (STU)",
    "  - When preserveOrder is true: other is appended to input, order preserved (STU)",
    "  - Combining empty with non-empty returns non-empty",
    "  - A.combine(B) where A:1,1,2,3 and B:2,3 \u2192 1,1,2,3,2,3 (order not guaranteed)",
    "  - A.combine(B, true) \u2192 1,1,2,3,2,3 (order preserved)",
    "  - A.combine({}) \u2192 1,1,2,3 (unchanged)",
    "",
    "=== INTERSECT ===",
    "intersect(other: collection) : collection",
    "  - Returns elements that are in BOTH collections using equals (=)",
    "  - Duplicates ARE eliminated (result is always distinct)",
    "  - Order NOT guaranteed",
    "  - Empty collection intersected with anything \u2192 empty",
    "  - Disjoint collections \u2192 empty",
    "",
    "=== EXCLUDE ===",
    "exclude(other: collection) : collection",
    "  - Returns elements NOT in other collection using equals (=)",
    "  - Duplicates are NOT eliminated (preserves duplicates in input)",
    "  - Order IS preserved (unlike union/intersect)",
    "  - (1|2|3).exclude(2) \u2192 (1|3) with order preserved",
    "  - Empty exclusion set \u2192 returns original collection unchanged",
    "  - Excluding from empty collection \u2192 empty",
    "",
    "=== EQUALITY SEMANTICS ===",
    "All functions use equals (=) for comparison, NOT equivalence (~):",
    "  - Integer 2 = Decimal 2.0 \u2192 true (implicit conversion)",
    "  - Decimal trailing zeros ignored: 1.0 = 1.00 \u2192 true",
    "  - String comparison based on Unicode values",
    "  - Complex types: all child properties must equal recursively",
    "",
    "=== EMPTY COLLECTION BEHAVIOR ===",
    "  - union({}) \u2192 distinct elements of non-empty operand",
    "  - {}.union(A) \u2192 distinct elements of A",
    "  - combine({}) \u2192 returns non-empty operand unchanged",
    "  - {}.combine(A) \u2192 returns A unchanged",
    "  - intersect({}) \u2192 empty",
    "  - {}.intersect(A) \u2192 empty",
    "  - exclude({}) \u2192 returns original unchanged",
    "  - {}.exclude(A) \u2192 empty"
  ],
  "_todo": [
    "[ ] Improve passing rate (18/65 passing) - 37 blocked by parser (| and {} operators)",
    "[x] Implement union/combine/intersect/exclude functions",
    "[x] Verify spec summary against official spec - enhanced with equality/empty semantics",
    "[x] Cross-check test expectations against spec and official tests",
    "[x] Fix tests that incorrectly assume order when spec says no order guarantee",
    "[ ] Test preserveOrder parameter for combine (STU feature) - not yet tested",
    "[ ] Add tests for complex object equality in union/intersect"
  ],
  "_open_questions": [
    "How should complex objects (FHIR resources) be compared for equality in union/intersect?",
    "Is the preserveOrder parameter widely supported by implementations?"
  ],
  "meta": {
    "status": "implemented"
  },
  "cases": [
    {
      "_section": "=== UNION BASIC ==="
    },
    {
      "name": "union: two disjoint integer collections",
      "expr": "(1 | 2).union(3 | 4).count()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 4
        }
      ]
    },
    {
      "name": "union: overlapping integer collections",
      "expr": "(1 | 2 | 3).union(2 | 3 | 4).count()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 4
        }
      ]
    },
    {
      "name": "union: identical collections",
      "expr": "(1 | 2).union(1 | 2).count()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 2
        }
      ]
    },
    {
      "name": "union: with empty collection (left)",
      "expr": "({}).union(1 | 2).count()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 2
        }
      ]
    },
    {
      "name": "union: with empty collection (right)",
      "expr": "(1 | 2).union({}).count()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 2
        }
      ]
    },
    {
      "name": "union: both empty",
      "expr": "({}).union({}).count()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 0
        }
      ]
    },
    {
      "name": "union: single elements",
      "expr": "1.union(2).count()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 2
        }
      ]
    },
    {
      "name": "union: same single element (deduplicates)",
      "expr": "1.union(1).count()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 1
        }
      ]
    },
    {
      "name": "union: chained",
      "expr": "1.union(2).union(3).count()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 3
        }
      ]
    },
    {
      "name": "union: nested",
      "expr": "1.union(2.union(3)).count()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 3
        }
      ]
    },
    {
      "name": "union: strings",
      "expr": "('a' | 'b').union('b' | 'c').count()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 3
        }
      ]
    },
    {
      "name": "union: booleans",
      "expr": "(true | false).union(true).count()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 2
        }
      ]
    },
    {
      "_section": "=== UNION VS | OPERATOR ==="
    },
    {
      "name": "union: equivalent to | operator",
      "expr": "(1 | 2).union(2 | 3) = (1 | 2 | 2 | 3)",
      "input": {},
      "expect": [
        {
          "type": "boolean",
          "value": true
        }
      ],
      "_note": "Both deduplicate, so result is same"
    },
    {
      "_section": "=== COMBINE BASIC ==="
    },
    {
      "name": "combine: two disjoint collections",
      "expr": "(1 | 2).combine(3 | 4).count()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 4
        }
      ]
    },
    {
      "name": "combine: overlapping collections (keeps duplicates)",
      "expr": "(1 | 2 | 3).combine(2 | 3 | 4).count()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 6
        }
      ]
    },
    {
      "name": "combine: identical collections (doubles count)",
      "expr": "(1 | 2).combine(1 | 2).count()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 4
        }
      ]
    },
    {
      "name": "combine: with empty collection (left)",
      "expr": "({}).combine(1 | 2).count()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 2
        }
      ]
    },
    {
      "name": "combine: with empty collection (right)",
      "expr": "(1 | 2).combine({}).count()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 2
        }
      ]
    },
    {
      "name": "combine: both empty",
      "expr": "({}).combine({}).count()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 0
        }
      ]
    },
    {
      "name": "combine: single elements",
      "expr": "1.combine(2).count()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 2
        }
      ]
    },
    {
      "name": "combine: same single element (keeps both)",
      "expr": "1.combine(1).count()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 2
        }
      ]
    },
    {
      "name": "combine: strings",
      "expr": "('a' | 'b').combine('b' | 'c').count()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 4
        }
      ]
    },
    {
      "_section": "=== COMBINE vs UNION ==="
    },
    {
      "name": "combine then union removes duplicates",
      "expr": "1.combine(1).union(2).count()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 2
        }
      ],
      "_note": "combine creates [1,1], union with 2 deduplicates to [1,2]"
    },
    {
      "name": "union then combine keeps duplicates",
      "expr": "(1 | 2).combine(2).count()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 3
        }
      ],
      "_note": "| creates [1,2], combine adds another 2 \u2192 [1,2,2]"
    },
    {
      "_section": "=== INTERSECT BASIC ==="
    },
    {
      "name": "intersect: overlapping collections",
      "expr": "(1 | 2 | 3).intersect(2 | 3 | 4).count()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 2
        }
      ],
      "_note": "Common elements are 2 and 3"
    },
    {
      "name": "intersect: disjoint collections",
      "expr": "(1 | 2).intersect(3 | 4).empty()",
      "input": {},
      "expect": [
        {
          "type": "boolean",
          "value": true
        }
      ]
    },
    {
      "name": "intersect: identical collections",
      "expr": "(1 | 2 | 3).intersect(1 | 2 | 3).count()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 3
        }
      ]
    },
    {
      "name": "intersect: with empty collection (left)",
      "expr": "({}).intersect(1 | 2).empty()",
      "input": {},
      "expect": [
        {
          "type": "boolean",
          "value": true
        }
      ]
    },
    {
      "name": "intersect: with empty collection (right)",
      "expr": "(1 | 2).intersect({}).empty()",
      "input": {},
      "expect": [
        {
          "type": "boolean",
          "value": true
        }
      ]
    },
    {
      "name": "intersect: single common element",
      "expr": "(1 | 2 | 3).intersect(2 | 4) = 2",
      "input": {},
      "expect": [
        {
          "type": "boolean",
          "value": true
        }
      ]
    },
    {
      "name": "intersect: strings",
      "expr": "('a' | 'b' | 'c').intersect('b' | 'c' | 'd').count()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 2
        }
      ]
    },
    {
      "name": "intersect: eliminates duplicates from input",
      "expr": "1.combine(1).intersect(1).count()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 1
        }
      ],
      "_note": "combine creates [1,1], intersect with 1 yields [1] (deduplicated)"
    },
    {
      "_section": "=== EXCLUDE BASIC ==="
    },
    {
      "name": "exclude: remove single element",
      "expr": "(1 | 2 | 3).exclude(2).count()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 2
        }
      ]
    },
    {
      "name": "exclude: remove multiple elements",
      "expr": "(1 | 2 | 3).exclude(2 | 4).count()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 2
        }
      ],
      "_note": "Removes 2, 4 not present so ignored"
    },
    {
      "name": "exclude: result equality check",
      "expr": "(1 | 2 | 3).exclude(2 | 4) = (1 | 3)",
      "input": {},
      "expect": [
        {
          "type": "boolean",
          "value": true
        }
      ]
    },
    {
      "name": "exclude: remove nothing (disjoint)",
      "expr": "(1 | 2).exclude(4) = (1 | 2)",
      "input": {},
      "expect": [
        {
          "type": "boolean",
          "value": true
        }
      ]
    },
    {
      "name": "exclude: with empty exclusion set",
      "expr": "(1 | 2).exclude({}) = (1 | 2)",
      "input": {},
      "expect": [
        {
          "type": "boolean",
          "value": true
        }
      ]
    },
    {
      "name": "exclude: from empty collection",
      "expr": "({}).exclude(1 | 2).empty()",
      "input": {},
      "expect": [
        {
          "type": "boolean",
          "value": true
        }
      ]
    },
    {
      "name": "exclude: all elements",
      "expr": "(1 | 2).exclude(1 | 2).empty()",
      "input": {},
      "expect": [
        {
          "type": "boolean",
          "value": true
        }
      ]
    },
    {
      "name": "exclude: preserves duplicates in input",
      "expr": "1.combine(1).exclude(2).count()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 2
        }
      ],
      "_note": "combine creates [1,1], exclude 2 keeps both 1s"
    },
    {
      "name": "exclude: strings",
      "expr": "('a' | 'b' | 'c').exclude('b').count()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 2
        }
      ]
    },
    {
      "_section": "=== PATH-BASED OPERATIONS ==="
    },
    {
      "name": "union: on path navigation",
      "expr": "a.union(b).count()",
      "input": {
        "a": [
          1,
          2
        ],
        "b": [
          2,
          3
        ]
      },
      "expect": [
        {
          "type": "integer",
          "value": 3
        }
      ]
    },
    {
      "name": "combine: on path navigation",
      "expr": "a.combine(b).count()",
      "input": {
        "a": [
          1,
          2
        ],
        "b": [
          2,
          3
        ]
      },
      "expect": [
        {
          "type": "integer",
          "value": 4
        }
      ]
    },
    {
      "name": "intersect: on path navigation",
      "expr": "a.intersect(b).count()",
      "input": {
        "a": [
          1,
          2,
          3
        ],
        "b": [
          2,
          3,
          4
        ]
      },
      "expect": [
        {
          "type": "integer",
          "value": 2
        }
      ]
    },
    {
      "name": "exclude: on path navigation",
      "expr": "a.exclude(b).count()",
      "input": {
        "a": [
          1,
          2,
          3
        ],
        "b": [
          2
        ]
      },
      "expect": [
        {
          "type": "integer",
          "value": 2
        }
      ]
    },
    {
      "_section": "=== COMPLEX COMBINATIONS ==="
    },
    {
      "name": "combine then exclude",
      "expr": "a.combine(b).exclude(c).count()",
      "input": {
        "a": [
          1,
          2
        ],
        "b": [
          2,
          3
        ],
        "c": [
          2
        ]
      },
      "expect": [
        {
          "type": "integer",
          "value": 2
        }
      ],
      "_note": "combine gives [1,2,2,3], exclude 2 gives [1,3]"
    },
    {
      "name": "union then intersect",
      "expr": "a.union(b).intersect(c).count()",
      "input": {
        "a": [
          1,
          2
        ],
        "b": [
          3,
          4
        ],
        "c": [
          2,
          3,
          5
        ]
      },
      "expect": [
        {
          "type": "integer",
          "value": 2
        }
      ],
      "_note": "union gives [1,2,3,4], intersect with [2,3,5] gives [2,3]"
    },
    {
      "name": "exclude then union",
      "expr": "a.exclude(b).union(c).count()",
      "input": {
        "a": [
          1,
          2,
          3
        ],
        "b": [
          2
        ],
        "c": [
          3,
          4
        ]
      },
      "expect": [
        {
          "type": "integer",
          "value": 3
        }
      ],
      "_note": "exclude gives [1,3], union with [3,4] gives [1,3,4]"
    },
    {
      "_section": "=== EDGE CASES ==="
    },
    {
      "name": "union: with decimals (equality test)",
      "expr": "(1.0 | 2.0).union(2.0 | 3.0).count()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 3
        }
      ],
      "_note": "2.0 should equal 2.0 and be deduplicated"
    },
    {
      "name": "intersect: integer and decimal equality",
      "expr": "(1 | 2).intersect(2.0 | 3.0).count()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 1
        }
      ],
      "_note": "2 = 2.0 per FHIRPath equality, so intersection has 1 element"
    },
    {
      "name": "union: nested collections from paths",
      "expr": "items.values.union(other.values).count()",
      "input": {
        "items": [
          {
            "values": [
              1,
              2
            ]
          },
          {
            "values": [
              3
            ]
          }
        ],
        "other": [
          {
            "values": [
              2,
              4
            ]
          }
        ]
      },
      "expect": [
        {
          "type": "integer",
          "value": 4
        }
      ],
      "_note": "Flattens to [1,2,3] union [2,4] = [1,2,3,4]"
    },
    {
      "name": "combine: count with path input (order not guaranteed)",
      "expr": "first.combine(second).count()",
      "input": {
        "first": [
          "a",
          "b"
        ],
        "second": [
          "c",
          "d"
        ]
      },
      "expect": [
        {
          "type": "integer",
          "value": 4
        }
      ],
      "_note": "Per spec: when preserveOrder is false/absent, no order guarantee. Test count instead."
    },
    {
      "_section": "=== BOOLEAN AND MIXED TYPES ==="
    },
    {
      "name": "union: mixed integers (count only - order not guaranteed)",
      "expr": "(1 | 2 | 3).union(3 | 4 | 5).count()",
      "input": {},
      "expect": [
        {
          "type": "integer",
          "value": 5
        }
      ],
      "_note": "Per spec: no expectation of order. Test count to verify deduplication."
    },
    {
      "name": "combine: result can be used with isDistinct",
      "expr": "(1 | 2).combine(2 | 3).isDistinct()",
      "input": {},
      "expect": [
        {
          "type": "boolean",
          "value": false
        }
      ],
      "_note": "combine keeps duplicates, so not distinct"
    },
    {
      "name": "union: result is always distinct",
      "expr": "(1 | 2).union(2 | 3).isDistinct()",
      "input": {},
      "expect": [
        {
          "type": "boolean",
          "value": true
        }
      ]
    }
  ]
}
