{
  "meta": {
    "status": "implemented",
    "spec_summary": "iif(criterion, true-result [, otherwise-result]) - Immediate if (conditional operator). Criterion MUST evaluate to a singleton Boolean or empty collection (spec says 'expected to evaluate to a Boolean'). Returns true-result if criterion is true; returns otherwise-result if criterion is false or empty; returns empty collection if otherwise-result is omitted and criterion is false/empty. Short-circuit evaluation is required: true-result only evaluated if criterion is true, otherwise-result only evaluated if criterion is false/empty. Multi-item criterion is an error. Non-boolean criterion (string, integer, etc.) is an error. When called as method (e.g., collection.iif(...)), multi-item input is an error - only singleton or empty input allowed.",
    "spec_ref": "spec/index.md lines 1005-1018",
    "verified_against_official": [
      "testCollectionBoolean1-6: criterion behaviors (empty, multi-item, short-circuit)",
      "testIif1-12: various iif patterns including method invocation",
      "Non-boolean criterion (testIif6) and multi-item input (testIif10) confirmed as errors"
    ],
    "todo": [
      "Improve passing rate (24/35 passing) - 11 tests blocked by parser (union operator |, division /, chaining on parenthesized expressions)"
    ]
  },
  "cases": [
    {
      "group": "basic true/false",
      "name": "criterion true returns true-result",
      "expr": "iif(true, 'yes', 'no')",
      "input": null,
      "expect": [
        {
          "type": "string",
          "value": "yes"
        }
      ]
    },
    {
      "group": "basic true/false",
      "name": "criterion false returns otherwise-result",
      "expr": "iif(false, 'yes', 'no')",
      "input": null,
      "expect": [
        {
          "type": "string",
          "value": "no"
        }
      ]
    },
    {
      "group": "basic true/false",
      "name": "integer results - true case",
      "expr": "iif(true, 1, 2)",
      "input": null,
      "expect": [
        {
          "type": "integer",
          "value": 1
        }
      ]
    },
    {
      "group": "basic true/false",
      "name": "integer results - false case",
      "expr": "iif(false, 1, 2)",
      "input": null,
      "expect": [
        {
          "type": "integer",
          "value": 2
        }
      ]
    },
    {
      "group": "empty criterion",
      "name": "empty criterion treated as false",
      "expr": "iif({}, 'yes', 'no')",
      "input": null,
      "expect": [
        {
          "type": "string",
          "value": "no"
        }
      ]
    },
    {
      "group": "empty criterion",
      "name": "union with true produces true",
      "expr": "iif({} | true, 'yes', 'no')",
      "input": null,
      "expect": [
        {
          "type": "string",
          "value": "yes"
        }
      ]
    },
    {
      "group": "empty criterion",
      "name": "union with false produces false",
      "expr": "iif({} | false, 'yes', 'no')",
      "input": null,
      "expect": [
        {
          "type": "string",
          "value": "no"
        }
      ]
    },
    {
      "group": "missing otherwise",
      "name": "true criterion with no otherwise returns true-result",
      "expr": "iif(true, 'yes')",
      "input": null,
      "expect": [
        {
          "type": "string",
          "value": "yes"
        }
      ]
    },
    {
      "group": "missing otherwise",
      "name": "false criterion with no otherwise returns empty",
      "expr": "iif(false, 'yes')",
      "input": null,
      "expect": []
    },
    {
      "group": "missing otherwise",
      "name": "empty criterion with no otherwise returns empty",
      "expr": "iif({}, 'yes')",
      "input": null,
      "expect": []
    },
    {
      "group": "missing otherwise",
      "name": "false criterion with no otherwise - empty check",
      "expr": "iif(false, 'yes').empty()",
      "input": null,
      "expect": [
        {
          "type": "boolean",
          "value": true
        }
      ]
    },
    {
      "group": "short-circuit evaluation",
      "name": "true criterion does not evaluate otherwise (div by zero)",
      "expr": "iif(true, 'safe', 1/0)",
      "input": null,
      "expect": [
        {
          "type": "string",
          "value": "safe"
        }
      ]
    },
    {
      "group": "short-circuit evaluation",
      "name": "false criterion does not evaluate true-result (div by zero)",
      "expr": "iif(false, 1/0, 'safe')",
      "input": null,
      "expect": [
        {
          "type": "string",
          "value": "safe"
        }
      ]
    },
    {
      "group": "short-circuit evaluation",
      "name": "empty criterion does not evaluate true-result",
      "expr": "iif({}, 1/0, 'safe')",
      "input": null,
      "expect": [
        {
          "type": "string",
          "value": "safe"
        }
      ]
    },
    {
      "group": "collection results",
      "name": "true-result can be a collection",
      "expr": "iif(true, 1 | 2 | 3, 0)",
      "input": null,
      "expect": [
        {
          "type": "integer",
          "value": 1
        },
        {
          "type": "integer",
          "value": 2
        },
        {
          "type": "integer",
          "value": 3
        }
      ]
    },
    {
      "group": "collection results",
      "name": "otherwise-result can be a collection",
      "expr": "iif(false, 0, 1 | 2 | 3)",
      "input": null,
      "expect": [
        {
          "type": "integer",
          "value": 1
        },
        {
          "type": "integer",
          "value": 2
        },
        {
          "type": "integer",
          "value": 3
        }
      ]
    },
    {
      "group": "collection results",
      "name": "true-result can be empty collection",
      "expr": "iif(true, {}, 'fallback')",
      "input": null,
      "expect": []
    },
    {
      "group": "collection results",
      "name": "otherwise-result can be empty collection",
      "expr": "iif(false, 'never', {})",
      "input": null,
      "expect": []
    },
    {
      "group": "context input",
      "name": "iif as method on empty collection",
      "expr": "{}.iif(true, 'yes', 'no')",
      "input": null,
      "expect": [
        {
          "type": "string",
          "value": "yes"
        }
      ]
    },
    {
      "group": "context input",
      "name": "iif as method on single item",
      "expr": "('item').iif(true, 'yes', 'no')",
      "input": null,
      "expect": [
        {
          "type": "string",
          "value": "yes"
        }
      ]
    },
    {
      "group": "context input",
      "name": "$this accessible in criterion",
      "expr": "('ctx').iif($this = 'ctx', 'match', 'no-match')",
      "input": null,
      "expect": [
        {
          "type": "string",
          "value": "match"
        }
      ]
    },
    {
      "group": "context input",
      "name": "$this accessible in true-result via select",
      "expr": "('ctx').iif(true, select($this), 'fallback')",
      "input": null,
      "expect": [
        {
          "type": "string",
          "value": "ctx"
        }
      ]
    },
    {
      "group": "context input",
      "name": "$this accessible in otherwise-result via select",
      "expr": "('ctx').iif(false, 'never', select($this))",
      "input": null,
      "expect": [
        {
          "type": "string",
          "value": "ctx"
        }
      ]
    },
    {
      "group": "with JSON input",
      "name": "criterion from input field - true case",
      "expr": "iif(active, 'active', 'inactive')",
      "input": {
        "active": true
      },
      "expect": [
        {
          "type": "string",
          "value": "active"
        }
      ]
    },
    {
      "group": "with JSON input",
      "name": "criterion from input field - false case",
      "expr": "iif(active, 'active', 'inactive')",
      "input": {
        "active": false
      },
      "expect": [
        {
          "type": "string",
          "value": "inactive"
        }
      ]
    },
    {
      "group": "with JSON input",
      "name": "criterion from missing field (empty)",
      "expr": "iif(missing, 'found', 'not-found')",
      "input": {
        "other": 1
      },
      "expect": [
        {
          "type": "string",
          "value": "not-found"
        }
      ]
    },
    {
      "group": "with JSON input",
      "name": "use exists() in criterion",
      "expr": "iif(name.exists(), 'has-name', 'no-name')",
      "input": {
        "name": "Alice"
      },
      "expect": [
        {
          "type": "string",
          "value": "has-name"
        }
      ]
    },
    {
      "group": "with JSON input",
      "name": "use empty() in criterion",
      "expr": "iif(name.empty(), 'no-name', 'has-name')",
      "input": {
        "name": "Alice"
      },
      "expect": [
        {
          "type": "string",
          "value": "has-name"
        }
      ]
    },
    {
      "group": "nested iif",
      "name": "nested iif in otherwise branch",
      "expr": "iif(false, 'first', iif(true, 'second', 'third'))",
      "input": null,
      "expect": [
        {
          "type": "string",
          "value": "second"
        }
      ]
    },
    {
      "group": "nested iif",
      "name": "nested iif in true-result branch",
      "expr": "iif(true, iif(false, 'a', 'b'), 'c')",
      "input": null,
      "expect": [
        {
          "type": "string",
          "value": "b"
        }
      ]
    },
    {
      "group": "nested iif",
      "name": "chained iif for multiple conditions",
      "expr": "iif(false, 1, iif(false, 2, iif(true, 3, 4)))",
      "input": null,
      "expect": [
        {
          "type": "integer",
          "value": 3
        }
      ]
    },
    {
      "group": "error cases",
      "name": "multi-item collection criterion is error",
      "expr": "iif(1 | 2 | 3, 'yes', 'no')",
      "input": null,
      "expect_error": true,
      "_adjudicated": {
        "fhirpath_js": [{"type": "string", "value": "no"}],
        "our_old_value": null,
        "verdict": "ours_correct",
        "reason": "Spec line 1003 states: 'The functions in this section operate on collections with a single item. If there is more than one item, the evaluation of the expression will end and signal an error.' The criterion (1 | 2 | 3) produces a 3-item collection of integers (not booleans), which must signal an error. fhirpath.js appears to use truthy/falsy coercion instead of enforcing the singleton Boolean requirement.",
        "spec_ref": "§5.4.1 iif(), preamble at line 1003"
      }
    },
    {
      "group": "error cases",
      "name": "non-boolean criterion (string) is error",
      "expr": "iif('string', 'yes', 'no')",
      "input": null,
      "expect_error": true
    },
    {
      "group": "error cases",
      "name": "non-boolean criterion (integer) is error",
      "expr": "iif(42, 'yes', 'no')",
      "input": null,
      "expect_error": true,
      "_adjudicated": {
        "fhirpath_js": [
          {
            "type": "string",
            "value": "no"
          }
        ],
        "our_old_value": null,
        "verdict": "ours_correct",
        "reason": "The iif() criterion is required to evaluate to a Boolean. There is no implicit Integer→Boolean conversion (only explicit toBoolean), so a non-boolean criterion should signal an error rather than be treated as false. This aligns with the spec’s wording for iif() and the official test case testIif6 that expects an error for non-boolean criteria.",
        "spec_ref": "§5.4.1 iif()"
      }
    },
    {
      "group": "error cases",
      "name": "multi-item input when using iif as method is error",
      "expr": "('a' | 'b').iif(true, 'yes', 'no')",
      "input": null,
      "expect_error": true
    }
  ]
}
