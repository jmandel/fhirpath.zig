{
  "meta": {
    "status": "reviewed"
  },
  "_spec_summary": "Regex matching functions: matches(), matchesFull(), replaceMatches(). All use regular expressions (PCRE flavor recommended). Case-sensitive by default, use 'single line' mode, allow Unicode.\n\n## matches(regex : String, [flags : String]) : Boolean\n- Returns true if the value contains a match for the given regex\n- Use ^ and $ anchors to match entire string\n- Empty input or regex returns empty\n- Multiple items in input is an error\n- Optional flags: 'i' for case-insensitive, 'm' for multi-line mode\n\n## matchesFull(regex : String, [flags : String]) : Boolean (STU)\n- Returns true if the value COMPLETELY matches the regex\n- Implicitly anchored at start and end (^ and $ surround the pattern)\n- Empty input or regex returns empty\n- Multiple items in input is an error\n- Optional flags: 'i' for case-insensitive, 'm' for multi-line mode\n\n## replaceMatches(regex : String, substitution : String, [flags : String]) : String\n- Replaces each regex match with the substitution string\n- Substitution can use named capture groups: ${groupname}\n- Empty input, regex, or substitution returns empty\n- Multiple items in input is an error\n- Optional flags: 'i' for case-insensitive, 'm' for multi-line mode\n\n## Key behaviors:\n- Regex is interpreted as PCRE (most portable)\n- Case-sensitive unless 'i' flag provided\n- **SINGLE-LINE MODE BY DEFAULT**: In single-line mode, '.' matches ANY character INCLUDING newlines. This is the default per spec.\n- **Multi-line mode ('m' flag)**: Makes ^ and $ match start/end of lines, not just start/end of string\n- Unicode characters allowed\n\n## IMPORTANT: Single-line mode semantics\nThe spec says regex should 'use single line mode'. In regex terminology, single-line mode means:\n- The '.' metacharacter matches ALL characters including \\n (newlines), \\r (carriage returns), etc.\n- Without single-line mode, '.' matches any character EXCEPT newlines\n- This is CRITICAL for patterns like 'A.*B' to match across line breaks\n\nNote: Some implementations call this 'DOTALL' mode or use the 's' flag.",
  "_todo": [
    "[ ] Improve passing rate (37/43 passing - 6 single-line mode tests failing)",
    "[x] Verify test expectations against spec examples",
    "[x] Review regex escape handling in tests",
    "[x] Numbered capture groups ($1, $2) are implemented",
    "[ ] Implement single-line mode (DOTALL) as default per spec",
    "[ ] Verify multi-line mode ('m' flag) behavior"
  ],
  "cases": [
    {
      "name": "matches: simple substring pattern",
      "expr": "'http://fhir.org/guides/cqf/common/Library/FHIR-ModelInfo|4.0.1'.matches('Library')",
      "input": {},
      "expect": [{"type": "boolean", "value": true}],
      "comment": "Spec example: partial match returns true"
    },
    {
      "name": "matches: anchored pattern fails on longer string",
      "expr": "'N8000123123'.matches('^N[0-9]{8}$')",
      "input": {},
      "expect": [{"type": "boolean", "value": false}],
      "comment": "Spec example: anchored to require exact 8 digits, but string has 10"
    },
    {
      "name": "matches: unanchored pattern succeeds on partial match",
      "expr": "'N8000123123'.matches('N[0-9]{8}')",
      "input": {},
      "expect": [{"type": "boolean", "value": true}],
      "comment": "Spec example: unanchored, matches first 9 chars"
    },
    {
      "name": "matches: no match returns false",
      "expr": "'hello world'.matches('xyz')",
      "input": {},
      "expect": [{"type": "boolean", "value": false}]
    },
    {
      "name": "matches: case sensitive by default",
      "expr": "'Hello'.matches('hello')",
      "input": {},
      "expect": [{"type": "boolean", "value": false}]
    },
    {
      "name": "matches: case insensitive with i flag",
      "expr": "'Hello'.matches('hello', 'i')",
      "input": {},
      "expect": [{"type": "boolean", "value": true}]
    },
    {
      "name": "matches: digit pattern",
      "expr": "'abc123def'.matches('[0-9]+')",
      "input": {},
      "expect": [{"type": "boolean", "value": true}]
    },
    {
      "name": "matches: dot matches any char",
      "expr": "'abc'.matches('a.c')",
      "input": {},
      "expect": [{"type": "boolean", "value": true}]
    },
    {
      "name": "matches: empty input returns empty",
      "expr": "{}.matches('pattern')",
      "input": {},
      "expect": []
    },
    {
      "name": "matches: empty regex returns empty",
      "expr": "'test'.matches({})",
      "input": {},
      "expect": []
    },
    {
      "name": "matches: word boundary",
      "expr": "'hello world'.matches('\\\\bworld\\\\b')",
      "input": {},
      "expect": [{"type": "boolean", "value": true}],
      "comment": "Word boundary matches 'world' as complete word"
    },
    {
      "name": "matches: alternation",
      "expr": "'cat'.matches('cat|dog')",
      "input": {},
      "expect": [{"type": "boolean", "value": true}]
    },
    {
      "name": "matchesFull: exact match required",
      "expr": "'http://fhir.org/guides/cqf/common/Library/FHIR-ModelInfo|4.0.1'.matchesFull('Library')",
      "input": {},
      "expect": [{"type": "boolean", "value": false}],
      "comment": "Spec example: matchesFull requires entire string to match"
    },
    {
      "name": "matchesFull: fails on partial match",
      "expr": "'N8000123123'.matchesFull('N[0-9]{8}')",
      "input": {},
      "expect": [{"type": "boolean", "value": false}],
      "comment": "Spec example: 10 digits doesn't match pattern for 8"
    },
    {
      "name": "matchesFull: exact digit count succeeds",
      "expr": "'N8000123123'.matchesFull('N[0-9]{10}')",
      "input": {},
      "expect": [{"type": "boolean", "value": true}],
      "comment": "Spec example: 10 digits matches pattern for 10"
    },
    {
      "name": "matchesFull: entire string must match",
      "expr": "'hello'.matchesFull('hello')",
      "input": {},
      "expect": [{"type": "boolean", "value": true}]
    },
    {
      "name": "matchesFull: pattern at start fails",
      "expr": "'hello world'.matchesFull('hello')",
      "input": {},
      "expect": [{"type": "boolean", "value": false}]
    },
    {
      "name": "matchesFull: case insensitive with i flag",
      "expr": "'HELLO'.matchesFull('hello', 'i')",
      "input": {},
      "expect": [{"type": "boolean", "value": true}]
    },
    {
      "name": "matchesFull: empty input returns empty",
      "expr": "{}.matchesFull('pattern')",
      "input": {},
      "expect": []
    },
    {
      "name": "matchesFull: empty regex returns empty",
      "expr": "'test'.matchesFull({})",
      "input": {},
      "expect": []
    },
    {
      "name": "matchesFull: wildcard pattern",
      "expr": "'abc123'.matchesFull('.*')",
      "input": {},
      "expect": [{"type": "boolean", "value": true}]
    },
    {
      "name": "matchesFull: mixed pattern",
      "expr": "'abc123'.matchesFull('[a-z]+[0-9]+')",
      "input": {},
      "expect": [{"type": "boolean", "value": true}]
    },
    {
      "name": "replaceMatches: simple replacement",
      "expr": "'aaabaa'.replaceMatches('aa', '\"aa\"')",
      "input": {},
      "expect": [{"type": "string", "value": "\"aa\"ab\"aa\""}],
      "comment": "Spec example: surrounds aa matches with quotes"
    },
    {
      "name": "replaceMatches: no match leaves string unchanged",
      "expr": "'hello'.replaceMatches('xyz', 'replaced')",
      "input": {},
      "expect": [{"type": "string", "value": "hello"}]
    },
    {
      "name": "replaceMatches: replace all occurrences",
      "expr": "'aaa'.replaceMatches('a', 'b')",
      "input": {},
      "expect": [{"type": "string", "value": "bbb"}]
    },
    {
      "name": "replaceMatches: empty input returns empty",
      "expr": "{}.replaceMatches('a', 'b')",
      "input": {},
      "expect": []
    },
    {
      "name": "replaceMatches: empty regex returns empty",
      "expr": "'test'.replaceMatches({}, 'x')",
      "input": {},
      "expect": []
    },
    {
      "name": "replaceMatches: empty substitution returns empty",
      "expr": "'test'.replaceMatches('e', {})",
      "input": {},
      "expect": []
    },
    {
      "name": "replaceMatches: case insensitive with i flag",
      "expr": "'Hello HELLO hello'.replaceMatches('hello', 'hi', 'i')",
      "input": {},
      "expect": [{"type": "string", "value": "hi hi hi"}]
    },
    {
      "name": "replaceMatches: digit replacement",
      "expr": "'abc123def'.replaceMatches('[0-9]+', 'NUM')",
      "input": {},
      "expect": [{"type": "string", "value": "abcNUMdef"}]
    },
    {
      "name": "replaceMatches: remove matches",
      "expr": "'a1b2c3'.replaceMatches('[0-9]', '')",
      "input": {},
      "expect": [{"type": "string", "value": "abc"}]
    },
    {
      "name": "replaceMatches: capture group substitution",
      "expr": "'abc'.replaceMatches('(.)(.)(.)','$3$2$1')",
      "input": {},
      "expect": [{"type": "string", "value": "cba"}],
      "comment": "Reverses string using numbered capture groups"
    },
    {
      "name": "matches: single-line mode - dot matches newline",
      "expr": "'A\nB'.matches('A.*B')",
      "input": {},
      "expect": [{"type": "boolean", "value": true}],
      "comment": "R5 testMatchesSingleLineMode1: spec says use single-line mode where . matches newlines"
    },
    {
      "name": "matches: single-line mode - dot matches tab and newlines",
      "expr": "'A\n\t\t\tB'.matches('A.*B')",
      "input": {},
      "expect": [{"type": "boolean", "value": true}],
      "comment": "R5 exact test: string with newline and tabs should match with .* pattern"
    },
    {
      "name": "matches: single-line mode - dot matches carriage return",
      "expr": "'A\rB'.matches('A.B')",
      "input": {},
      "expect": [{"type": "boolean", "value": true}],
      "comment": "Carriage return should also be matched by . in single-line mode"
    },
    {
      "name": "matches: single-line mode - dot matches across multiple lines",
      "expr": "'line1\nline2\nline3'.matches('line1.*line3')",
      "input": {},
      "expect": [{"type": "boolean", "value": true}],
      "comment": "Pattern should match across multiple line breaks"
    },
    {
      "name": "matchesFull: single-line mode - dot matches newline",
      "expr": "'A\nB'.matchesFull('A.*B')",
      "input": {},
      "expect": [{"type": "boolean", "value": true}],
      "comment": "matchesFull should also use single-line mode"
    },
    {
      "name": "matchesFull: single-line mode - dot matches any character",
      "expr": "'first\nsecond'.matchesFull('first.second')",
      "input": {},
      "expect": [{"type": "boolean", "value": true}],
      "comment": "Single . should match the newline character"
    },
    {
      "name": "replaceMatches: single-line mode - dot matches newline",
      "expr": "'A\nB'.replaceMatches('A.B', 'X')",
      "input": {},
      "expect": [{"type": "string", "value": "X"}],
      "comment": "replaceMatches should also use single-line mode"
    },
    {
      "name": "matches: multiline mode - caret matches start of line",
      "expr": "'line1\nline2'.matches('^line2', 'm')",
      "input": {},
      "expect": [{"type": "boolean", "value": true}],
      "comment": "With 'm' flag, ^ matches start of any line, not just start of string"
    },
    {
      "name": "matches: multiline mode - dollar matches end of line",
      "expr": "'line1\nline2'.matches('line1$', 'm')",
      "input": {},
      "expect": [{"type": "boolean", "value": true}],
      "comment": "With 'm' flag, $ matches end of any line, not just end of string"
    },
    {
      "name": "matches: without multiline mode - caret only matches start of string",
      "expr": "'line1\nline2'.matches('^line2')",
      "input": {},
      "expect": [{"type": "boolean", "value": false}],
      "comment": "Without 'm' flag, ^ only matches absolute start of string"
    },
    {
      "name": "matches: without multiline mode - dollar only matches end of string",
      "expr": "'line1\nline2'.matches('line1$')",
      "input": {},
      "expect": [{"type": "boolean", "value": false}],
      "comment": "Without 'm' flag, $ only matches absolute end of string"
    }
  ]
}
