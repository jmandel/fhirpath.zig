{
  "meta": {
    "status": "drafted",
    "spec_summary": "String manipulation functions for FHIRPath. All functions operate on a single string; if input is empty, result is empty; if multiple items, signals error.",
    "spec_sections": ["String Manipulation", "Additional String Functions"],
    "todo": [
      "Improve passing rate (0/68 passing)",
      "Verify edge cases for empty string inputs vs empty collection inputs",
      "Add tests for error signaling on multiple items (when harness supports error expectations)"
    ],
    "open_questions": [
      "split() with empty separator - spec doesn't specify behavior, test assumes empty result"
    ]
  },
  "cases": [
    {
      "name": "length - basic string",
      "expr": "'abcdefg'.length()",
      "input": {},
      "expect": [7]
    },
    {
      "name": "length - empty string",
      "expr": "''.length()",
      "input": {},
      "expect": [0]
    },
    {
      "name": "length - single char",
      "expr": "'x'.length()",
      "input": {},
      "expect": [1]
    },
    {
      "name": "length - empty collection returns empty",
      "expr": "{}.length().empty()",
      "input": {},
      "expect": [true]
    },
    {
      "name": "length - path-based",
      "expr": "name.length()",
      "input": {"name": "hello"},
      "expect": [5]
    },

    {
      "name": "indexOf - basic",
      "expr": "'abcdefg'.indexOf('bc')",
      "input": {},
      "expect": [1]
    },
    {
      "name": "indexOf - at start",
      "expr": "'abcdefg'.indexOf('abc')",
      "input": {},
      "expect": [0]
    },
    {
      "name": "indexOf - at end",
      "expr": "'abcdefg'.indexOf('efg')",
      "input": {},
      "expect": [4]
    },
    {
      "name": "indexOf - not found returns -1",
      "expr": "'abcdefg'.indexOf('x')",
      "input": {},
      "expect": [-1]
    },
    {
      "name": "indexOf - entire string",
      "expr": "'abcdefg'.indexOf('abcdefg')",
      "input": {},
      "expect": [0]
    },
    {
      "name": "indexOf - empty substring returns 0",
      "expr": "'abcdefg'.indexOf('')",
      "input": {},
      "expect": [0]
    },
    {
      "name": "indexOf - empty collection input returns empty",
      "expr": "{}.indexOf('x').empty()",
      "input": {},
      "expect": [true]
    },
    {
      "name": "indexOf - empty collection substring returns empty",
      "expr": "'abc'.indexOf({}).empty()",
      "input": {},
      "expect": [true]
    },
    {
      "name": "indexOf - case sensitive",
      "expr": "'ABC'.indexOf('abc')",
      "input": {},
      "expect": [-1]
    },

    {
      "name": "lastIndexOf - basic",
      "expr": "'abcdefg'.lastIndexOf('bc')",
      "input": {},
      "expect": [1]
    },
    {
      "name": "lastIndexOf - not found",
      "expr": "'abcdefg'.lastIndexOf('x')",
      "input": {},
      "expect": [-1]
    },
    {
      "name": "lastIndexOf - entire string",
      "expr": "'abcdefg'.lastIndexOf('abcdefg')",
      "input": {},
      "expect": [0]
    },
    {
      "name": "lastIndexOf - finds last occurrence",
      "expr": "'abc abc'.lastIndexOf('a')",
      "input": {},
      "expect": [4]
    },
    {
      "name": "lastIndexOf - empty substring returns length",
      "expr": "'0123'.lastIndexOf('')",
      "input": {},
      "expect": [4]
    },
    {
      "name": "lastIndexOf - single char with empty substring",
      "expr": "'0'.lastIndexOf('')",
      "input": {},
      "expect": [1]
    },
    {
      "name": "lastIndexOf - empty string with empty substring",
      "expr": "''.lastIndexOf('')",
      "input": {},
      "expect": [0]
    },

    {
      "name": "upper - lowercase to uppercase",
      "expr": "'abcdefg'.upper()",
      "input": {},
      "expect": ["ABCDEFG"]
    },
    {
      "name": "upper - mixed case",
      "expr": "'AbCdefg'.upper()",
      "input": {},
      "expect": ["ABCDEFG"]
    },
    {
      "name": "upper - already uppercase",
      "expr": "'ABC'.upper()",
      "input": {},
      "expect": ["ABC"]
    },
    {
      "name": "upper - empty string",
      "expr": "''.upper()",
      "input": {},
      "expect": [""]
    },
    {
      "name": "upper - empty collection returns empty",
      "expr": "{}.upper().empty()",
      "input": {},
      "expect": [true]
    },
    {
      "name": "upper - single char",
      "expr": "'t'.upper()",
      "input": {},
      "expect": ["T"]
    },

    {
      "name": "lower - uppercase to lowercase",
      "expr": "'ABCDEFG'.lower()",
      "input": {},
      "expect": ["abcdefg"]
    },
    {
      "name": "lower - mixed case",
      "expr": "'aBcDEFG'.lower()",
      "input": {},
      "expect": ["abcdefg"]
    },
    {
      "name": "lower - already lowercase",
      "expr": "'abc'.lower()",
      "input": {},
      "expect": ["abc"]
    },
    {
      "name": "lower - empty string",
      "expr": "''.lower()",
      "input": {},
      "expect": [""]
    },
    {
      "name": "lower - empty collection returns empty",
      "expr": "{}.lower().empty()",
      "input": {},
      "expect": [true]
    },
    {
      "name": "lower - single char",
      "expr": "'T'.lower()",
      "input": {},
      "expect": ["t"]
    },

    {
      "name": "replace - basic replacement",
      "expr": "'abcdefg'.replace('cde', '123')",
      "input": {},
      "expect": ["ab123fg"]
    },
    {
      "name": "replace - removal (empty substitution)",
      "expr": "'abcdefg'.replace('cde', '')",
      "input": {},
      "expect": ["abfg"]
    },
    {
      "name": "replace - empty pattern surrounds chars",
      "expr": "'abc'.replace('', 'x')",
      "input": {},
      "expect": ["xaxbxcx"]
    },
    {
      "name": "replace - no match leaves unchanged",
      "expr": "'abcdefg'.replace('xyz', '123')",
      "input": {},
      "expect": ["abcdefg"]
    },
    {
      "name": "replace - multiple occurrences",
      "expr": "'abcabc'.replace('abc', 'X')",
      "input": {},
      "expect": ["XX"]
    },
    {
      "name": "replace - empty input collection returns empty",
      "expr": "{}.replace('a', 'b').empty()",
      "input": {},
      "expect": [true]
    },
    {
      "name": "replace - empty pattern collection returns empty",
      "expr": "'abc'.replace({}, 'x').empty()",
      "input": {},
      "expect": [true]
    },
    {
      "name": "replace - empty substitution collection returns empty",
      "expr": "'abc'.replace('a', {}).empty()",
      "input": {},
      "expect": [true]
    },

    {
      "name": "trim - leading and trailing whitespace",
      "expr": "' hello '.trim()",
      "input": {},
      "expect": ["hello"]
    },
    {
      "name": "trim - leading whitespace only",
      "expr": "'   hello'.trim()",
      "input": {},
      "expect": ["hello"]
    },
    {
      "name": "trim - trailing whitespace only",
      "expr": "'hello   '.trim()",
      "input": {},
      "expect": ["hello"]
    },
    {
      "name": "trim - no whitespace",
      "expr": "'hello'.trim()",
      "input": {},
      "expect": ["hello"]
    },
    {
      "name": "trim - all whitespace",
      "expr": "'   '.trim()",
      "input": {},
      "expect": [""]
    },
    {
      "name": "trim - empty string",
      "expr": "''.trim()",
      "input": {},
      "expect": [""]
    },
    {
      "name": "trim - empty collection returns empty",
      "expr": "{}.trim().empty()",
      "input": {},
      "expect": [true]
    },
    {
      "name": "trim - preserves internal whitespace",
      "expr": "' hello world '.trim()",
      "input": {},
      "expect": ["hello world"]
    },

    {
      "name": "toChars - basic",
      "expr": "'abc'.toChars()",
      "input": {},
      "expect": ["a", "b", "c"]
    },
    {
      "name": "toChars - single char",
      "expr": "'x'.toChars()",
      "input": {},
      "expect": ["x"]
    },
    {
      "name": "toChars - empty string",
      "expr": "''.toChars().empty()",
      "input": {},
      "expect": [true]
    },
    {
      "name": "toChars - empty collection returns empty",
      "expr": "{}.toChars().empty()",
      "input": {},
      "expect": [true]
    },

    {
      "name": "split - basic with comma",
      "expr": "'A,B,C'.split(',')",
      "input": {},
      "expect": ["A", "B", "C"]
    },
    {
      "name": "split - no separator found",
      "expr": "'ABC'.split(',')",
      "input": {},
      "expect": ["ABC"]
    },
    {
      "name": "split - empty segments",
      "expr": "'A,,C'.split(',')",
      "input": {},
      "expect": ["A", "", "C"]
    },
    {
      "name": "split - multi-char separator",
      "expr": "'A[stop]B[stop]C'.split('[stop]')",
      "input": {},
      "expect": ["A", "B", "C"]
    },
    {
      "name": "split - empty collection returns empty",
      "expr": "{}.split(',').empty()",
      "input": {},
      "expect": [true]
    },

    {
      "name": "join - basic without separator",
      "expr": "('A' | 'B' | 'C').join()",
      "input": {},
      "expect": ["ABC"]
    },
    {
      "name": "join - with comma separator",
      "expr": "('A' | 'B' | 'C').join(',')",
      "input": {},
      "expect": ["A,B,C"]
    },
    {
      "name": "join - single item",
      "expr": "('A').join(',')",
      "input": {},
      "expect": ["A"]
    },
    {
      "name": "join - empty collection returns empty",
      "expr": "{}.join(',').empty()",
      "input": {},
      "expect": [true]
    },
    {
      "name": "join - roundtrip with split",
      "expr": "'A,,C'.split(',').join(',')",
      "input": {},
      "expect": ["A,,C"]
    },

    {
      "name": "combined - substring with length",
      "expr": "'hello'.substring(0, 'hello'.length())",
      "input": {},
      "expect": ["hello"]
    },
    {
      "name": "combined - indexOf for substring extraction",
      "expr": "'LogicalModel-Person'.substring(0, 'LogicalModel-Person'.indexOf('-'))",
      "input": {},
      "expect": ["LogicalModel"]
    },
    {
      "name": "combined - upper and lower",
      "expr": "'HeLLo'.lower().upper()",
      "input": {},
      "expect": ["HELLO"]
    },
    {
      "name": "combined - trim and length",
      "expr": "' hello '.trim().length()",
      "input": {},
      "expect": [5]
    },
    {
      "name": "combined - split count",
      "expr": "'a,b,c,d,e'.split(',').count()",
      "input": {},
      "expect": [5]
    }
  ]
}
